!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AND	src/ops.h	1;"	d
AND_SubTree	src/prps.c	?^int AND_SubTree(PrpsTree **tree)$?;"	f
A_Contains	src/_list.h	?^Args *A_Contains(Args **args, char *arg)$?;"	f
AddOperator	uneeded/generate.h	?^void AddOperator(PrpsT **tree)//, PrpsT **$?;"	f
AddOprtr	src/_tree_synth.h	?^void AddOprtr(OprtrList ***oprtr_list_head, int oprtr)$?;"	f
AddOprtr	src/_tree_synth.old.h	?^void AddOprtr(OprtrList ***oprtr_list_head, int oprtr)$?;"	f
AddStmnt	src/tester.c	?^void AddStmnt(FindList **list, char *prps, char **arg, $?;"	f
AddToken	src/_list.h	?^void AddToken(Tokens **head, char *token)$?;"	f
AddTree	src/_tree_synth.h	?^void AddTree(Tokens **tokens, Tokens **arg_list,$?;"	f
AddTree	src/_tree_synth.old.h	?^void AddTree(Tokens **tokens, Tokens **arg_list,$?;"	f
AddTreeNode	src/_tree_synth.h	?^void AddTreeNode(TreeList ***tree_list_head, $?;"	f
AddTreeNode	src/_tree_synth.old.h	?^void AddTreeNode(TreeList ***tree_list_head, $?;"	f
AdvanceToClosingParenthese	src/_tree_synth.h	?^void AdvanceToClosingParenthese(Tokens **tokens)$?;"	f
AdvanceToClosingParenthese	src/_tree_synth.old.h	?^void AdvanceToClosingParenthese(Tokens **tokens)$?;"	f
AllocateAsOprtr	src/_tree_gen.h	?^void AllocateAsOprtr(PrpsTree **node, int oprtr)$?;"	f
AllocateAsPrps	src/_tree_gen.h	?^void AllocateAsPrps(PrpsTree **node, char *prps, char **arg, int n_args)$?;"	f
AlphaToTree	src/_tree_synth.h	?^PrpsTree **AlphaToTree(char *input, int *hash_val)$?;"	f
AlphaToTree	src/_tree_synth.old.h	?^PrpsTree **AlphaToTree(char *input, int *hash_val)$?;"	f
AlreadyMallocErr	src/err.h	?^void AlreadyMallocErr(const char *msg)$?;"	f
ArgNmbr	src/parse.h	?^typedef struct ArgNmbr$?;"	s
ArgNmbr	src/parse.h	?^} ArgNmbr;$?;"	t	typeref:struct:ArgNmbr
ArgNode	src/hash.h	?^typedef struct ArgNode$?;"	s
ArgNode	src/hash.h	?^} ArgNode;$?;"	t	typeref:struct:ArgNode
ArgNode	uneeded/hash_alloc.h	?^typedef struct ArgNode$?;"	s
ArgNode	uneeded/hash_alloc.h	?^} ArgNode;$?;"	t	typeref:struct:ArgNode
ArgNode	uneeded/hash_check.h	?^typedef struct ArgNode$?;"	s
ArgNode	uneeded/hash_check.h	?^} ArgNode;$?;"	t	typeref:struct:ArgNode
Args	src/parse.h	?^typedef struct Args$?;"	s
Args	src/parse.h	?^} Args;$?;"	t	typeref:struct:Args
BOTH	src/ops.h	11;"	d
CC	Makefile	?^CC=colorgcc$?;"	m
CC	test/Makefile	?^CC=colorgcc$?;"	m
CFLAGS	Makefile	?^CFLAGS=-ggdb3 -Isrc/ -I./ -lm$?;"	m
CFLAGS	test/Makefile	?^CFLAGS=-ggdb3 -Isrc/ -I./ -lm$?;"	m
CNF	src/prps.c	?^void CNF(PrpsTree **tree, int d)$?;"	f
CNF_Step	src/prps.c	?^void CNF_Step(PrpsTree **tree, void (**pfi)())$?;"	f
CheckChildrenOprtr	src/_prps_err.h	?^void CheckChildrenOprtr(PrpsTree **tree, int oprtr)$?;"	f
CheckConsistency	src/_prps_err.h	?^void CheckConsistency(PrpsTree **tree)$?;"	f
CheckEqualNodes	src/prps.c	?^int CheckEqualNodes(PrpsTree **node_a, PrpsTree **node_b)$?;"	f
CheckEqualSubTrees	src/prps.c	?^int CheckEqualSubTrees(PrpsTree **tree_a, PrpsTree **tree_b)$?;"	f
CheckOprtrNode	src/_prps_err.h	?^void CheckOprtrNode(PrpsTree **tree)$?;"	f
CheckPrpsTreeNode	src/_prps_err.h	?^void CheckPrpsTreeNode(PrpsTree **tree)$?;"	f
ClauseList	src/tester.h	?^typedef struct ClauseList$?;"	s
ClauseList	src/tester.h	?^} ClauseList;$?;"	t	typeref:struct:ClauseList
CompareArgs	src/tester.c	?^int CompareArgs(char **args_a, char **args_b, int n_args_a, int n_args_b)$?;"	f
ContainsAnd	src/prps.c	?^int ContainsAnd(PrpsTree **tree)$?;"	f
ContainsClause	src/tester.c	?^int ContainsClause(ClauseList **clause, FindList **P_new)$?;"	f
ContainsLiteral	src/tester.c	?^int ContainsLiteral(FindList **Pa, FindList **Pb)$?;"	f
ContainsOnlyPositiveORs	src/prps.c	?^int ContainsOnlyPositiveORs(PrpsTree **tree)$?;"	f
ConvertIMP	src/prps.c	?^void ConvertIMP(PrpsTree **tree)$?;"	f
ConvertIsOR	src/prps.c	?^void ConvertIsOR(PrpsTree **tree)$?;"	f
ConvertNotAnd	src/prps.c	?^void ConvertNotAnd(PrpsTree **tree)$?;"	f
ConvertNotOr	src/prps.c	?^void ConvertNotOr(PrpsTree **tree)$?;"	f
ConvertTAU	src/prps.c	?^void ConvertTAU(PrpsTree **tree)$?;"	f
CopyArgs	src/tester.c	?^char **CopyArgs(PrpsTree **node, int *n_args)$?;"	f
CopyNode	src/prps.c	?^PrpsTree **CopyNode(PrpsTree **node)$?;"	f
CopySubTree	src/prps.c	?^PrpsTree **CopySubTree(PrpsTree **tree)$?;"	f
DeallocateFromOprtr	src/_tree_gen.h	?^void DeallocateFromOprtr(PrpsTree **node)$?;"	f
DeallocateFromPrps	src/_tree_gen.h	?^void DeallocateFromPrps(PrpsTree **node)$?;"	f
DeathErr	src/err.h	?^void DeathErr(const char *msg)$?;"	f
DeepestOprtr	src/prps.c	?^int DeepestOprtr(PrpsTree **node)$?;"	f
DefaultsToTrue	src/tester.c	?^int DefaultsToTrue(FindList **list)$?;"	f
DepthFirstTraversal	src/tester.c	?^void DepthFirstTraversal(PrpsTree **clause, FindList **list)$?;"	f
DetatchChild	src/prps.c	?^PrpsTree **DetatchChild(PrpsTree **tree, int dir)$?;"	f
DetatchParent	src/prps.c	?^PrpsTree **DetatchParent(PrpsTree **tree, int *dir)$?;"	f
DetatchParentLeft	src/prps.c	?^PrpsTree **DetatchParentLeft(PrpsTree **tree)$?;"	f
DetatchParentRight	src/prps.c	?^PrpsTree **DetatchParentRight(PrpsTree **tree)$?;"	f
DistributeOrs	src/prps.c	?^void DistributeOrs(PrpsTree **tree, PrpsTree **tree_insert)$?;"	f
DistributeOrs_Caller	src/prps.c	?^void DistributeOrs_Caller(PrpsTree **tree)$?;"	f
EXISTS	src/ops.h	17;"	d
E_AddArg	src/_list.h	?^void E_AddArg(Tokens **e_args, char *arg)$?;"	f
E_GetIndex	src/_list.h	?^int E_GetIndex(Tokens **tokens, char *token)$?;"	f
ElliminateClause	src/tester.c	?^void ElliminateClause(FindList **clause)$?;"	f
ElliminateDefaultTrues	src/tester.c	?^int ElliminateDefaultTrues(ClauseList **clause_list)$?;"	f
ElliminateInnerOrs	src/prps.c	?^void ElliminateInnerOrs(PrpsTree **tree)$?;"	f
EqualClauses	src/tester.c	?^int EqualClauses(FindList **Pa, FindList **Pb)$?;"	f
FALSE	src/ops.h	13;"	d
FORALL	src/ops.h	18;"	d
FindList	src/tester.h	?^typedef struct FindList$?;"	s
FindList	src/tester.h	?^} FindList;$?;"	t	typeref:struct:FindList
FreeArgs	src/_list.h	?^void FreeArgs(Args **args)$?;"	f
FreeOprtrList	src/_tree_synth.h	?^void FreeOprtrList(OprtrList **oprtr_list)$?;"	f
FreeOprtrList	src/_tree_synth.old.h	?^void FreeOprtrList(OprtrList **oprtr_list)$?;"	f
FreeSymbolArray	src/tester.c	?^void FreeSymbolArray(char ***symbols, unsigned long int n, unsigned int m)$?;"	f
FreeTokens	src/_list.h	?^void FreeTokens(Tokens **tokens)$?;"	f
FreeTreeList	src/_tree_synth.h	?^void FreeTreeList(TreeList **tree_list)$?;"	f
FreeTreeList	src/_tree_synth.old.h	?^void FreeTreeList(TreeList **tree_list)$?;"	f
GenArgs	src/tester.c	?^char **GenArgs(char *input, int *i)$?;"	f
GenPrps	src/tester.c	?^char *GenPrps(char *input, int *i)$?;"	f
GenSequentialSymbol	src/tester.c	?^void GenSequentialSymbol(char **symbol, int f, int m)$?;"	f
GenSymbol	src/tester.c	?^void GenSymbol(char **symbol, int n)$?;"	f
GenSymbolArray	src/tester.c	?^void GenSymbolArray(char ***symbols, unsigned long int n, unsigned int m)$?;"	f
GenerateAllocatedHashTable	src/hash.c	?^HashTable **GenerateAllocatedHashTable(int m, int n)$?;"	f
GenerateAllocatedHashTable	uneeded/hash_alloc.h	?^HashTable *GenerateAllocatedHashTable(int m, int n)$?;"	f
GenerateEmpty	src/_tree_gen.h	?^PrpsTree *GenerateEmpty()$?;"	f
GetArg	src/parse.c	?^void GetArg(char ***arg, char *input, int *i, int *arg_n)$?;"	f
GetArgIndex	src/hash.c	?^int GetArgIndex(char arg[], int n)$?;"	f
GetClauses	src/tester.c	?^void GetClauses(PrpsTree **tree, ClauseList **head, ClauseList **tail, $?;"	f
GetLeftMostByte	src/tester.c	?^void GetLeftMostByte(int *f, int *nmbr)$?;"	f
GetOprtr	src/parse.c	?^int GetOprtr(char symbol)$?;"	f
GetPropIndex	src/hash.c	?^int GetPropIndex(char prop[], int m)$?;"	f
GetPrps	src/parse.c	?^void GetPrps(char **prps, char *input, int *i)$?;"	f
GetType	src/prps.c	?^int GetType(PrpsTree **node)$?;"	f
GetValueForArg	src/hash.c	?^int GetValueForArg(char prop[], char arg[], HashTable **hash, int m, int n)$?;"	f
HASH_H	src/hash.h	2;"	d
HasComplimentary	src/tester.c	?^int HasComplimentary(FindList **clause, FindList **literal)$?;"	f
HashNode	src/hash.h	?^typedef struct HashNode$?;"	s
HashNode	src/hash.h	?^} HashNode;$?;"	t	typeref:struct:HashNode
HashNode	uneeded/hash_alloc.h	?^typedef struct HashNode$?;"	s
HashNode	uneeded/hash_alloc.h	?^} HashNode;$?;"	t	typeref:struct:HashNode
HashNode	uneeded/hash_check.h	?^typedef struct HashNode$?;"	s
HashNode	uneeded/hash_check.h	?^} HashNode;$?;"	t	typeref:struct:HashNode
HashTable	src/hash.h	?^typedef struct HashTable$?;"	s
HashTable	src/hash.h	?^} HashTable;$?;"	t	typeref:struct:HashTable
HashTable	uneeded/hash_alloc.h	?^typedef struct HashTable$?;"	s
HashTable	uneeded/hash_alloc.h	?^} HashTable;$?;"	t	typeref:struct:HashTable
HashTable	uneeded/hash_check.h	?^typedef struct HashTable$?;"	s
HashTable	uneeded/hash_check.h	?^} HashTable;$?;"	t	typeref:struct:HashTable
IMP	src/ops.h	4;"	d
INFINITY	uneeded/printing/asciinode.h	175;"	d
IS	src/ops.h	20;"	d
InconsistencyErr	src/err.h	?^void InconsistencyErr(const char *msg)$?;"	f
IncrementConditional	src/parse.c	?^int IncrementConditional(Tokens **arg_list, Args **u_args_ptr, char quant)$?;"	f
IsCNF	src/prps.c	?^int IsCNF(PrpsTree **tree)$?;"	f
IsLeftChild	src/prps.c	?^int IsLeftChild(PrpsTree **tree)$?;"	f
IsLowerCase	src/parse.c	?^int IsLowerCase(char c)$?;"	f
IsOprtr	src/parse.c	?^int IsOprtr(char token)$?;"	f
IsRightChild	src/prps.c	?^int IsRightChild(PrpsTree **tree)$?;"	f
IsUpperCase	src/parse.c	?^int IsUpperCase(char c)$?;"	f
KB_And	src/kb.h	?^int KB_And(int left_val, int right_val)$?;"	f
KB_Not	src/kb.h	?^int KB_Not(int val)$?;"	f
KB_Or	src/kb.h	?^int KB_Or(int left_val, int right_val)$?;"	f
KB_Tau	src/kb.h	?^int KB_Tau(int left_val, int right_val)$?;"	f
LEFT	src/ops.h	8;"	d
LOWER_CASE_FIRST	src/ops.h	24;"	d
LOWER_CASE_LAST	src/ops.h	25;"	d
LeafNode	src/prps.c	?^int LeafNode(PrpsTree **tree)$?;"	f
List	src/_list.h	?^char *List(Tokens **tokens, int index)$?;"	f
ListAddTree	src/_tree_synth.h	?^void ListAddTree(TreeList ***tree_list_head, PrpsTree **tree_tmp)$?;"	f
ListAddTree	src/_tree_synth.old.h	?^void ListAddTree(TreeList ***tree_list_head, PrpsTree **tree_tmp)$?;"	f
ListLen	src/_list.h	?^int ListLen(Args **args)$?;"	f
MAX	uneeded/printing/asciinode.h	?^int MAX (int X, int Y)  $?;"	f
MAX_HEIGHT	uneeded/printing/asciinode.h	172;"	d
MIN	uneeded/printing/asciinode.h	?^int MIN (int X, int Y)  $?;"	f
MallocErr	src/err.h	?^void MallocErr(const char *msg) $?;"	f
MaxCharsExceededWarn	src/err.h	?^void MaxCharsExceededWarn(const char *chars)$?;"	f
MergeOrs	src/prps.c	?^void MergeOrs(PrpsTree **tree)$?;"	f
MyString	src/prps.h	?^typedef struct MyString$?;"	s
MyString	src/prps.h	?^} MyString;$?;"	t	typeref:struct:MyString
MyString	uneeded/hash_alloc.h	?^typedef struct MyString$?;"	s
MyString	uneeded/hash_alloc.h	?^} MyString;$?;"	t	typeref:struct:MyString
MyString	uneeded/hash_check.h	?^typedef struct MyString$?;"	s
MyString	uneeded/hash_check.h	?^} MyString;$?;"	t	typeref:struct:MyString
NO	src/ops.h	14;"	d
NONE	src/ops.h	10;"	d
NOT	src/ops.h	21;"	d
Negate	src/prps.c	?^void Negate(PrpsTree **node)$?;"	f
NoArgWarn	src/err.h	?^void NoArgWarn(const char *msg)$?;"	f
NoMallocErr	src/err.h	?^void NoMallocErr(const char *msg)$?;"	f
OPRTR	src/ops.h	6;"	d
OR	src/ops.h	2;"	d
Oprtr	src/prps.c	?^PrpsTree **Oprtr(int neg_a, PrpsTree **tree_a, int neg_b, PrpsTree **tree_b, $?;"	f
Oprtr2	src/prps.c	?^PrpsTree **Oprtr2(int neg_a, PrpsTree **tree, int neg_b, char *prps, char **arg, int n_args, int neg_oprtr, int oprtr)$?;"	f
OprtrList	src/parse.h	?^typedef struct OprtrList$?;"	s
OprtrList	src/parse.h	?^} OprtrList;$?;"	t	typeref:struct:OprtrList
OprtrNode	src/prps.c	?^int OprtrNode(PrpsTree **tree)$?;"	f
OprtrNodeType	src/prps.c	?^int OprtrNodeType(PrpsTree **node, int neg, int oprtr)$?;"	f
OprtrWrap	src/prps.c	?^PrpsTree **OprtrWrap(int neg_a, PrpsTree **tree, int neg_b, char *prps, char **arg, $?;"	f
PARSE_H	src/parse.h	2;"	d
PL_Resolve	src/tester.c	?^int PL_Resolve(FindList **Pa, FindList **Pb, ClauseList ***ptr_head)$?;"	f
PL_Resolve_2	src/tester.c	?^int PL_Resolve_2(FindList **Pa, FindList **Pb, $?;"	f
PRPS	src/ops.h	7;"	d
PRPS_H	src/prps.h	2;"	d
ParseErr	src/err.h	?^void ParseErr(const char *msg)$?;"	f
PrpsNode	src/prps.c	?^int PrpsNode(PrpsTree **node)$?;"	f
PrpsTokenizer	src/_tree_synth.h	?^Tokens *PrpsTokenizer(char *input, int *n)$?;"	f
PrpsTokenizer	src/_tree_synth.old.h	?^Tokens *PrpsTokenizer(char *input, int *n)$?;"	f
PrpsTree	src/prps.h	?^typedef struct PrpsTree$?;"	s
PrpsTree	src/prps.h	?^} PrpsTree;$?;"	t	typeref:struct:PrpsTree
PrpsTree	uneeded/printing/print.h	?^struct PrpsTree $?;"	s
QuantifierToTree	src/_tree_synth.h	?^PrpsTree **QuantifierToTree(Tokens **tokens, Tokens **arg_list, $?;"	f
QuantifierToTree	src/_tree_synth.old.h	?^PrpsTree **QuantifierToTree(Tokens **tokens, Tokens **arg_list, $?;"	f
RIGHT	src/ops.h	9;"	d
Read	src/parse.c	?^PrpsTree **Read(PrpsTree ***tree, int h, int k, int *hash_val)$?;"	f
ReadArgs	src/parse.c	?^Tokens **ReadArgs(char *input, int n)$?;"	f
ReadKB	src/_read.h	?^char **ReadKB(int m, const char *filename)$?;"	f
ReadPRPS	src/_read.h	?^char *ReadPRPS(const char *filename)$?;"	f
Resolution	src/tester.c	?^int Resolution(PrpsTree **tree)$?;"	f
Resolve	src/tester.c	?^int Resolve(ClauseList **clause_list)$?;"	f
SPACE	src/ops.h	23;"	d
SetArg	src/_list.h	?^void SetArg(Tokens **arg_list, Tokens **e_args, Args **u_args, $?;"	f
SetChild	src/prps.c	?^void SetChild(PrpsTree **parent, PrpsTree **child, int dir)$?;"	f
SetLeftChild	src/prps.c	?^void SetLeftChild(PrpsTree **parent, PrpsTree **child)$?;"	f
SetRightChild	src/prps.c	?^void SetRightChild(PrpsTree **parent, PrpsTree **child)$?;"	f
SetValueForArg	src/hash.c	?^void SetValueForArg(char prop[], char arg[], int value, HashTable **hash, int m, int n)$?;"	f
SyntaxErr	src/err.h	?^void SyntaxErr(const char *msg)$?;"	f
TAU	src/ops.h	5;"	d
TESTER_H	src/tester.h	2;"	d
TESTS	test/Makefile	?^TESTS = unit_fixtures$?;"	m
TRUE	src/ops.h	12;"	d
T_Contains	src/_list.h	?^int T_Contains(Tokens **args, char *arg)$?;"	f
TestErr	src/err.h	?^void TestErr(const char *msg)$?;"	f
Tokens	src/parse.h	?^typedef struct Tokens$?;"	s
Tokens	src/parse.h	?^} Tokens;$?;"	t	typeref:struct:Tokens
TokensToTree	src/_tree_synth.h	?^PrpsTree **TokensToTree(Tokens **tokens, Tokens **arg_list, $?;"	f
TokensToTree	src/_tree_synth.old.h	?^PrpsTree **TokensToTree(Tokens **tokens, Tokens **arg_list, $?;"	f
TraverseLeft	src/prps.c	?^PrpsTree **TraverseLeft(PrpsTree **tree)$?;"	f
Tree	uneeded/printing/asciinode.h	?^struct Tree $?;"	s
Tree	uneeded/printing/asciinode.h	?^typedef struct Tree Tree;$?;"	t	typeref:struct:Tree
TreeConsistency	src/prps.c	?^void TreeConsistency(PrpsTree **tree)$?;"	f
TreeList	src/parse.h	?^typedef struct TreeList$?;"	s
TreeList	src/parse.h	?^} TreeList;$?;"	t	typeref:struct:TreeList
TreeListToTree	src/_tree_synth.h	?^PrpsTree **TreeListToTree(TreeList *tree_list, OprtrList *oprtr_list)$?;"	f
TreeListToTree	src/_tree_synth.old.h	?^PrpsTree **TreeListToTree(TreeList *tree_list, OprtrList *oprtr_list)$?;"	f
UPPER_CASE_FIRST	src/ops.h	26;"	d
UPPER_CASE_LAST	src/ops.h	27;"	d
U_AddArg	src/_list.h	?^void U_AddArg(Tokens **arg_list, Args **u_args, char *arg)$?;"	f
U_E_QuantifierToTree	src/_tree_synth.h	?^PrpsTree **U_E_QuantifierToTree(Tokens **tokens, Tokens **arg_list, $?;"	f
U_E_QuantifierToTree	src/_tree_synth.old.h	?^PrpsTree **U_E_QuantifierToTree(Tokens **tokens, Tokens **arg_list, $?;"	f
U_GetIndex	src/_list.h	?^int U_GetIndex(Args **args, char *arg)$?;"	f
YES	src/ops.h	15;"	d
addArg	src/_hash_alloc.org.h	?^void addArg(char prop[], char arg[], HashTable **hash, int m, int n)$?;"	f
addArg	uneeded/hash_alloc.h	?^void addArg(char prps[], char arg[], HashTable **hash, int m, int n)$?;"	f
addSymbol	src/_hash_alloc.org.h	?^void addSymbol(char prop[], HashTable **hash, int m, int n)$?;"	f
addSymbol	uneeded/hash_alloc.h	?^void addSymbol(char prps[], HashTable **hash, int m, int n)$?;"	f
allocateArgNode	src/_hash_alloc.org.h	?^void allocateArgNode(char arg[], ArgNode **arg_ptr_ptr, int rgu, int s, int n)$?;"	f
allocateArgNode	uneeded/hash_alloc.h	?^void allocateArgNode(char arg[], ArgNode **arg_ptr_ptr, int rgu, int s, int n)$?;"	f
allocateEmptyArgNode	src/_hash_alloc.h	?^void allocateEmptyArgNode(ArgNode **arg_ptr_ptr)$?;"	f
allocateEmptyArgNode	src/_hash_alloc.org.h	?^void allocateEmptyArgNode(ArgNode **arg_ptr_ptr)$?;"	f
allocateEmptyArgNode	uneeded/hash_alloc.h	?^void allocateEmptyArgNode(ArgNode **arg_ptr_ptr)$?;"	f
allocateEmptyHashNode	src/_hash_alloc.h	?^void allocateEmptyHashNode(HashNode **node_ptr_ptr)$?;"	f
allocateEmptyHashNode	src/_hash_alloc.org.h	?^void allocateEmptyHashNode(HashNode **node_ptr_ptr)$?;"	f
allocateEmptyHashNode	uneeded/hash_alloc.h	?^void allocateEmptyHashNode(HashNode **node_ptr_ptr)$?;"	f
allocateNonEmptyArgNode	src/_hash_alloc.org.h	?^void allocateNonEmptyArgNode(ArgNode **arg_ptr_ptr, int s, int n)$?;"	f
allocateNonEmptyArgNode	uneeded/hash_alloc.h	?^void allocateNonEmptyArgNode(ArgNode **arg_ptr_ptr, int s, int n)$?;"	f
allocateNonEmptyHashNode	src/_hash_alloc.h	?^void allocateNonEmptyHashNode(HashNode **node_ptr_ptr, int s, int n)$?;"	f
allocateNonEmptyHashNode	src/_hash_alloc.org.h	?^void allocateNonEmptyHashNode(HashNode **node_ptr_ptr, int s, int n)$?;"	f
allocateNonEmptyHashNode	uneeded/hash_alloc.h	?^void allocateNonEmptyHashNode(HashNode **node_ptr_ptr, int s, int n)$?;"	f
allocateNonEmptyString	src/_hash_alloc.h	?^void allocateNonEmptyString(MyString **arg_ptr_ptr, int s)$?;"	f
allocateNonEmptyString	src/_tree_gen.h	?^void allocateNonEmptyString(MyString **arg_ptr_ptr, int s)$?;"	f
allocateNonEmptyString	uneeded/hash_alloc.h	?^void allocateNonEmptyString(MyString **arg_ptr_ptr, int s)$?;"	f
allocatePropNode	src/_hash_alloc.org.h	?^void allocatePropNode(char prop[], HashNode **node_ptr_ptr, int prp, int s, int n)$?;"	f
allocatePrpsNode	uneeded/hash_alloc.h	?^void allocatePrpsNode(char prps[], HashNode **node_ptr_ptr, int prp, int s, int n)$?;"	f
arg	src/hash.h	?^{   MyString *arg; // Argument name$?;"	m	struct:ArgNode
arg	src/tester.h	?^    char *prps, **arg;$?;"	m	struct:FindList
arg	uneeded/hash_alloc.h	?^{   MyString *arg; // Argument name$?;"	m	struct:ArgNode
arg	uneeded/hash_check.h	?^{   MyString *arg; // Argument name$?;"	m	struct:ArgNode
arg_ptr	src/hash.h	?^    ArgNode *arg_ptr;   // Pointer variable used to set and retriev $?;"	m	struct:HashNode
arg_ptr	uneeded/hash_alloc.h	?^    ArgNode *arg_ptr;   // Pointer variable used to set and retriev $?;"	m	struct:HashNode
arg_ptr	uneeded/hash_check.h	?^    ArgNode *arg_ptr;   // Pointer variable used to set and retriev $?;"	m	struct:HashNode
arg_ptr_ptr	src/_hash_alloc.h	?^    checkArgNodeNonEmpty(arg_ptr_ptr);$?;"	v
argmnt	src/prps.h	?^    MyString *stmnt, **argmnt;$?;"	m	struct:PrpsTree
array	src/hash.h	?^    ArgNode *array;     // Array holding values corresponding to the $?;"	m	struct:HashNode
array	uneeded/hash_alloc.h	?^    ArgNode *array;     // Array holding values corresponding to the $?;"	m	struct:HashNode
array	uneeded/hash_check.h	?^    ArgNode *array;     // Array holding values corresponding to the $?;"	m	struct:HashNode
asciinode	uneeded/printing/asciinode.h	?^typedef struct asciinode_struct asciinode;$?;"	t	typeref:struct:asciinode_struct
asciinode_struct	uneeded/printing/asciinode.h	?^struct asciinode_struct$?;"	s
asciinode_struct	uneeded/printing/print.h	?^struct asciinode_struct$?;"	s
build_ascii_tree	uneeded/printing/asciinode.h	?^asciinode * build_ascii_tree(Tree * t) $?;"	f
build_ascii_tree	uneeded/printing/print.h	?^asciinode * build_ascii_tree(PrpsTree * t) $?;"	f
build_ascii_tree_recursive	uneeded/printing/asciinode.h	?^asciinode * build_ascii_tree_recursive(Tree * t) $?;"	f
build_ascii_tree_recursive	uneeded/printing/print.h	?^asciinode * build_ascii_tree_recursive(PrpsTree * t) $?;"	f
checkArgNodeEmpty	src/_hash_check.h	?^void checkArgNodeEmpty(ArgNode **arg_ptr)$?;"	f
checkArgNodeEmpty	uneeded/hash_alloc.h	?^void checkArgNodeEmpty(ArgNode **arg_ptr)$?;"	f
checkArgNodeEmpty	uneeded/hash_check.h	?^void checkArgNodeEmpty(ArgNode **arg_ptr)$?;"	f
checkArgNodeEmpty2	src/_hash_check.h	?^void checkArgNodeEmpty2(ArgNode **arg_ptr)$?;"	f
checkArgNodeEmpty2	uneeded/hash_alloc.h	?^void checkArgNodeEmpty2(ArgNode **arg_ptr)$?;"	f
checkArgNodeEmpty2	uneeded/hash_check.h	?^void checkArgNodeEmpty2(ArgNode **arg_ptr)$?;"	f
checkArgNodeNonEmpty	src/_hash_check.h	?^void checkArgNodeNonEmpty(ArgNode **arg_ptr)$?;"	f
checkArgNodeNonEmpty	uneeded/hash_alloc.h	?^void checkArgNodeNonEmpty(ArgNode **arg_ptr)$?;"	f
checkArgNodeNonEmpty	uneeded/hash_check.h	?^void checkArgNodeNonEmpty(ArgNode **arg_ptr)$?;"	f
checkHashNodeEmpty	src/_hash_check.h	?^void checkHashNodeEmpty(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeEmpty	uneeded/hash_alloc.h	?^void checkHashNodeEmpty(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeEmpty	uneeded/hash_check.h	?^void checkHashNodeEmpty(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeNonEmpty	src/_hash_check.h	?^void checkHashNodeNonEmpty(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeNonEmpty	uneeded/hash_alloc.h	?^void checkHashNodeNonEmpty(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeNonEmpty	uneeded/hash_check.h	?^void checkHashNodeNonEmpty(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeNonEmpty2	src/_hash_check.h	?^void checkHashNodeNonEmpty2(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeNonEmpty2	uneeded/hash_alloc.h	?^void checkHashNodeNonEmpty2(HashNode **node_ptr_ptr)$?;"	f
checkHashNodeNonEmpty2	uneeded/hash_check.h	?^void checkHashNodeNonEmpty2(HashNode **node_ptr_ptr)$?;"	f
checkHashTableEmpty	src/_hash_check.h	?^void checkHashTableEmpty(HashTable **hash)$?;"	f
checkHashTableEmpty	uneeded/hash_alloc.h	?^void checkHashTableEmpty(HashTable **hash)$?;"	f
checkHashTableEmpty	uneeded/hash_check.h	?^void checkHashTableEmpty(HashTable **hash)$?;"	f
checkHashTableNonEmpty	src/_hash_check.h	?^void checkHashTableNonEmpty(HashTable **hash)$?;"	f
checkHashTableNonEmpty	uneeded/hash_alloc.h	?^void checkHashTableNonEmpty(HashTable **hash)$?;"	f
checkHashTableNonEmpty	uneeded/hash_check.h	?^void checkHashTableNonEmpty(HashTable **hash)$?;"	f
checkStringEmpty	src/_tree_gen.h	?^void checkStringEmpty(MyString **arg_ptr_ptr, int arg_n)$?;"	f
checkStringEmpty	uneeded/hash_alloc.h	?^void checkStringEmpty(MyString **arg_ptr_ptr)$?;"	f
checkStringEmpty	uneeded/hash_check.h	?^void checkStringEmpty(MyString **arg_ptr_ptr)$?;"	f
checkStringNonEmpty	src/_tree_gen.h	?^void checkStringNonEmpty(MyString **arg_name)$?;"	f
checkStringNonEmpty	uneeded/hash_alloc.h	?^void checkStringNonEmpty(MyString **arg_name)$?;"	f
checkStringNonEmpty	uneeded/hash_check.h	?^void checkStringNonEmpty(MyString **arg_name)$?;"	f
check_PROGRAMS	test/Makefile	?^check_PROGRAMS = unit_fixtures$?;"	m
clause	src/tester.h	?^    FindList **clause;$?;"	m	struct:ClauseList
compute_edge_lengths	uneeded/printing/asciinode.h	?^void compute_edge_lengths(asciinode *node) $?;"	f
compute_edge_lengths	uneeded/printing/print.h	?^void compute_edge_lengths(asciinode *node) $?;"	f
compute_lprofile	uneeded/printing/asciinode.h	?^void compute_lprofile(asciinode *node, int x, int y) $?;"	f
compute_lprofile	uneeded/printing/print.h	?^void compute_lprofile(asciinode *node, int x, int y) $?;"	f
compute_rprofile	uneeded/printing/asciinode.h	?^void compute_rprofile(asciinode *node, int x, int y) $?;"	f
compute_rprofile	uneeded/printing/print.h	?^void compute_rprofile(asciinode *node, int x, int y) $?;"	f
edge_length	uneeded/printing/asciinode.h	?^  int edge_length; $?;"	m	struct:asciinode_struct
edge_length	uneeded/printing/print.h	?^  int edge_length; $?;"	m	struct:asciinode_struct
element	uneeded/printing/asciinode.h	?^  int element;$?;"	m	struct:Tree
element	uneeded/printing/print.h	?^  int element;$?;"	m	struct:PrpsTree
find	uneeded/printing/asciinode.h	?^Tree *find(int elem, Tree *t)$?;"	f
find_max	uneeded/printing/asciinode.h	?^Tree *find_max(Tree *t)$?;"	f
find_min	uneeded/printing/asciinode.h	?^Tree *find_min(Tree *t)$?;"	f
free_ascii_tree	uneeded/printing/asciinode.h	?^void free_ascii_tree(asciinode *node) $?;"	f
free_ascii_tree	uneeded/printing/print.h	?^void free_ascii_tree(asciinode *node) $?;"	f
gap	uneeded/printing/asciinode.h	?^int gap = 3;  $?;"	v
generateEmptyHashTable	src/hash.c	?^HashTable **generateEmptyHashTable()$?;"	f
generateEmptyHashTable	uneeded/hash_alloc.h	?^HashTable *generateEmptyHashTable()$?;"	f
head	src/hash.h	?^    struct HashNode *head;$?;"	m	struct:HashNode	typeref:struct:HashNode::HashNode
head	uneeded/hash_alloc.h	?^    struct HashNode *head;$?;"	m	struct:HashNode	typeref:struct:HashNode::HashNode
head	uneeded/hash_check.h	?^    struct HashNode *head;$?;"	m	struct:HashNode	typeref:struct:HashNode::HashNode
height	uneeded/printing/asciinode.h	?^  int height;      $?;"	m	struct:asciinode_struct
height	uneeded/printing/print.h	?^  int height;      $?;"	m	struct:asciinode_struct
insert	uneeded/printing/asciinode.h	?^Tree * insert(int value, Tree * t) $?;"	f
is	src/tester.h	?^    int is, is_not;$?;"	m	struct:FindList
is_not	src/tester.h	?^    int is, is_not;$?;"	m	struct:FindList
label	uneeded/printing/asciinode.h	?^  char label[11];  $?;"	m	struct:asciinode_struct
label	uneeded/printing/print.h	?^  char label[11];  $?;"	m	struct:asciinode_struct
lablen	uneeded/printing/asciinode.h	?^  int lablen;$?;"	m	struct:asciinode_struct
lablen	uneeded/printing/print.h	?^  int lablen;$?;"	m	struct:asciinode_struct
left	src/prps.h	?^    struct PrpsTree *left;      // left child$?;"	m	struct:PrpsTree	typeref:struct:PrpsTree::PrpsTree
left	uneeded/printing/asciinode.h	?^  Tree * left, * right;$?;"	m	struct:Tree
left	uneeded/printing/asciinode.h	?^  asciinode * left, * right;$?;"	m	struct:asciinode_struct
left	uneeded/printing/print.h	?^  PrpsTree * left, * right;$?;"	m	struct:PrpsTree
left	uneeded/printing/print.h	?^  asciinode * left, * right;$?;"	m	struct:asciinode_struct
lprofile	uneeded/printing/asciinode.h	?^int lprofile[MAX_HEIGHT];$?;"	v
m	src/hash.h	?^    int *m;             // Number of hash nodes$?;"	m	struct:HashTable
m	uneeded/hash_alloc.h	?^    int *m;             // Number of hash nodes$?;"	m	struct:HashTable
m	uneeded/hash_check.h	?^    int *m;             // Number of hash nodes$?;"	m	struct:HashTable
main	main.c	?^int main()$?;"	f
main	uneeded/printing/asciinode.h	?^void main() $?;"	f
main	uneeded/printing/main.c	?^int main()$?;"	f
make_empty	uneeded/printing/asciinode.h	?^Tree *make_empty(Tree *t)$?;"	f
n	src/hash.h	?^    int *n;             // Number of elements per hash node$?;"	m	struct:HashTable
n	src/hash.h	?^{   int *n;             // Length of array held by node$?;"	m	struct:HashNode
n	uneeded/hash_alloc.h	?^    int *n;             // Number of elements per hash node$?;"	m	struct:HashTable
n	uneeded/hash_alloc.h	?^{   int *n;             // Length of array held by node$?;"	m	struct:HashNode
n	uneeded/hash_check.h	?^    int *n;             // Number of elements per hash node$?;"	m	struct:HashTable
n	uneeded/hash_check.h	?^{   int *n;             // Length of array held by node$?;"	m	struct:HashNode
n_args	src/prps.h	?^    int n_args;$?;"	m	struct:PrpsTree
n_args	src/tester.h	?^    int n_args;$?;"	m	struct:FindList
name	src/hash.h	?^    MyString *name;     // String corresponding to the name$?;"	m	struct:HashNode
name	uneeded/hash_alloc.h	?^    MyString *name;// String corresponding to the name$?;"	m	struct:HashNode
name	uneeded/hash_check.h	?^    MyString *name;// String corresponding to the name$?;"	m	struct:HashNode
neg	src/prps.h	?^    int *neg;           // = 1 if negated, otherwise 0$?;"	m	struct:PrpsTree
next	src/hash.h	?^    struct ArgNode *next;   // Next hash node.$?;"	m	struct:ArgNode	typeref:struct:ArgNode::ArgNode
next	src/hash.h	?^    struct HashNode *next;$?;"	m	struct:HashNode	typeref:struct:HashNode::HashNode
next	src/parse.h	?^    struct ArgNmbr *next;$?;"	m	struct:ArgNmbr	typeref:struct:ArgNmbr::ArgNmbr
next	src/parse.h	?^    struct Args *next;$?;"	m	struct:Args	typeref:struct:Args::Args
next	src/parse.h	?^    struct OprtrList *next;$?;"	m	struct:OprtrList	typeref:struct:OprtrList::OprtrList
next	src/parse.h	?^    struct Tokens *next;$?;"	m	struct:Tokens	typeref:struct:Tokens::Tokens
next	src/parse.h	?^    struct TreeList *next;$?;"	m	struct:TreeList	typeref:struct:TreeList::TreeList
next	src/tester.h	?^    struct ClauseList *prev, *next;$?;"	m	struct:ClauseList	typeref:struct:ClauseList::
next	src/tester.h	?^    struct FindList *next;$?;"	m	struct:FindList	typeref:struct:FindList::FindList
next	uneeded/hash_alloc.h	?^    struct ArgNode *next;   // Next hash node.$?;"	m	struct:ArgNode	typeref:struct:ArgNode::ArgNode
next	uneeded/hash_alloc.h	?^    struct HashNode *next;$?;"	m	struct:HashNode	typeref:struct:HashNode::HashNode
next	uneeded/hash_check.h	?^    struct ArgNode *next;   // Next hash node.$?;"	m	struct:ArgNode	typeref:struct:ArgNode::ArgNode
next	uneeded/hash_check.h	?^    struct HashNode *next;$?;"	m	struct:HashNode	typeref:struct:HashNode::HashNode
node_ptr	src/hash.h	?^    HashNode *node_ptr; // Pointer so that gcc will let me allocate $?;"	m	struct:HashTable
node_ptr	uneeded/hash_alloc.h	?^    HashNode *node_ptr; // Pointer so that gcc will let me allocate $?;"	m	struct:HashTable
node_ptr	uneeded/hash_check.h	?^    HashNode *node_ptr; // Pointer so that gcc will let me allocate $?;"	m	struct:HashTable
nodes	src/hash.h	?^    HashNode *nodes;    // Array of HashNode structs$?;"	m	struct:HashTable
nodes	uneeded/hash_alloc.h	?^    HashNode *nodes;    // Array of HashNode structs$?;"	m	struct:HashTable
nodes	uneeded/hash_check.h	?^    HashNode *nodes;    // Array of HashNode structs$?;"	m	struct:HashTable
oprtr	src/parse.h	?^    int oprtr;$?;"	m	struct:OprtrList
oprtr	src/prps.h	?^    int *oprtr;         // var indicating type of logic operator$?;"	m	struct:PrpsTree
p	src/prps.h	?^    struct PrpsTree *p;         // parent node$?;"	m	struct:PrpsTree	typeref:struct:PrpsTree::PrpsTree
parent_dir	uneeded/printing/asciinode.h	?^  int parent_dir;   $?;"	m	struct:asciinode_struct
parent_dir	uneeded/printing/print.h	?^  int parent_dir;   $?;"	m	struct:asciinode_struct
prev	src/tester.h	?^    struct ClauseList *prev, *next;$?;"	m	struct:ClauseList	typeref:struct:ClauseList::ClauseList
print_args	src/_tree_synth.h	?^void print_args(Args *args)$?;"	f
print_args	src/_tree_synth.old.h	?^void print_args(Args *args)$?;"	f
print_ascii_tree	uneeded/printing/asciinode.h	?^void print_ascii_tree(Tree * t) $?;"	f
print_ascii_tree	uneeded/printing/print.h	?^void print_ascii_tree(PrpsTree * t) $?;"	f
print_clause_list	src/tester.c	?^void print_clause_list(ClauseList **clause_list, int a, int b)$?;"	f
print_level	uneeded/printing/asciinode.h	?^void print_level(asciinode *node, int x, int level) $?;"	f
print_level	uneeded/printing/print.h	?^void print_level(asciinode *node, int x, int level) $?;"	f
print_next	uneeded/printing/asciinode.h	?^int print_next;    $?;"	v
print_oprtr	src/_prps_err.h	?^void print_oprtr(int oprtr)$?;"	f
print_tokens	src/_tree_synth.h	?^void print_tokens(Tokens *tokens)$?;"	f
print_tokens	src/_tree_synth.old.h	?^void print_tokens(Tokens *tokens)$?;"	f
prps	src/tester.h	?^    char *prps, **arg;$?;"	m	struct:FindList
result	src/hash.h	?^    int *result;        // Result of passing argument arg to proposition$?;"	m	struct:ArgNode
result	uneeded/hash_alloc.h	?^    int *result;        // Result of passing argument arg to prpsosition$?;"	m	struct:ArgNode
result	uneeded/hash_check.h	?^    int *result;        // Result of passing argument arg to prpsosition$?;"	m	struct:ArgNode
right	src/prps.h	?^    struct PrpsTree *right;     // right child$?;"	m	struct:PrpsTree	typeref:struct:PrpsTree::PrpsTree
right	uneeded/printing/asciinode.h	?^  Tree * left, * right;$?;"	m	struct:Tree
right	uneeded/printing/asciinode.h	?^  asciinode * left, * right;$?;"	m	struct:asciinode_struct
right	uneeded/printing/print.h	?^  PrpsTree * left, * right;$?;"	m	struct:PrpsTree
right	uneeded/printing/print.h	?^  asciinode * left, * right;$?;"	m	struct:asciinode_struct
rprofile	uneeded/printing/asciinode.h	?^int rprofile[MAX_HEIGHT];$?;"	v
s	src/parse.h	?^    int s, t;$?;"	m	struct:ArgNmbr
s	src/prps.h	?^{   int *s;$?;"	m	struct:MyString
s	uneeded/hash_alloc.h	?^{   int *s;$?;"	m	struct:MyString
s	uneeded/hash_check.h	?^{   int *s;$?;"	m	struct:MyString
setPointerToArg	src/_hash_alloc.org.h	?^int setPointerToArg(char arg[], HashTable **hash, int m, int n)$?;"	f
setPointerToArg	uneeded/hash_alloc.h	?^int setPointerToArg(char arg[], HashTable **hash, int m, int n)$?;"	f
setPointerToProp	src/_hash_alloc.org.h	?^int setPointerToProp(char prop[], HashTable **hash, int m, int n)$?;"	f
setPointerToPrps	uneeded/hash_alloc.h	?^int setPointerToPrps(char prps[], HashTable **hash, int m, int n)$?;"	f
stc	src/prps.h	?^    char *stc;$?;"	m	struct:MyString
stc	uneeded/hash_alloc.h	?^    char *stc;$?;"	m	struct:MyString
stc	uneeded/hash_check.h	?^    char *stc;$?;"	m	struct:MyString
stmnt	src/prps.h	?^    MyString *stmnt, **argmnt;$?;"	m	struct:PrpsTree
t	src/parse.h	?^    int s, t;$?;"	m	struct:ArgNmbr
test_cnf	test_main.c	?^int test_cnf(PrpsTree **tree, int d)$?;"	f
token	src/parse.h	?^    char *token;$?;"	m	struct:Args
token	src/parse.h	?^    char *token;$?;"	m	struct:Tokens
token_ptr	src/parse.h	?^    Tokens *token_ptr;$?;"	m	struct:Args
tree	src/parse.h	?^    PrpsTree **tree;$?;"	m	struct:TreeList
tree_print	src/_prps_err.h	?^void tree_print(PrpsTree **tree)$?;"	f
unit_fixtures_SOURCES	test/Makefile	?^unit_fixtures_SOURCES = unit_fixtures.c $(top_buliddir)/src/main.c$?;"	m
value	src/prps.h	?^    int value;          // Truth value of subtree$?;"	m	struct:PrpsTree
